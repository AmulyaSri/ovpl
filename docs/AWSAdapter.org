#+title: AWSAdapter for ADS
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org
#+OPTIONS: ^:nil


* Introduction
An adapter is an ADS component, which is responsible for creating and
managing VMs on a particular platform.

The =AWSAdapter= is an adapter for the AWS platform.

In the following document, the words *instance* and *VM* have been used
interchangeably.


* Requirements
  1. =AWSAdapter= will create a VM on AWS based on the specification
     given in the lab spec for a particular lab.

  2. =AWSAdapter= will copy the =VMManager= component to the newly
     created VM and start the =VMManager= service.

  3. Pre-requisites for the =AWSAdapter=:
     + The =AdapterServer= which communicates with this adapter is running on
       AWS.
     + The =AdapterServer= is configured to use the =AWSAdapter=.
     + Appropriate parameters for the adapter are configured in the
       =aws_config.py= file (explained below).
     + The AWS key pair is placed in the appropriate location, which is same
       as what is configured in the =aws_config.py= file.


* Design
** Interfaces
In the current design of ADS, a fixed set of interfaces to an adapter
is already defined. An adapter is required to implement these
interfaces. This enables other components/services of ADS to
communicate with the adapter. The interfaces implemented by the
AWSAdapter are listed below:

1. *create_vm* (self, lab_spec, dry_run=False)

     Creates a new VM.

     *Parameters*:
                 + lab_spec - Lists the lab and VM related reqirements.
                 + dry_run(bool) - Set to True if the operation should not actually run.

     *Returns*: Instance id of the newly created Amazon VM.

2. *start_vm* (self, vm_id, dry_run=False)

     Starts the VM identified by =vm_id=.

     *Parameters*:
                 + vm_id - VM/instance id of the VM to be started.
                 + dry_run(bool) - Set to True if the operation should not actually run.

     *Returns*: List of instances that got started.

3. *stop_vm* (self, vm_id, dry_run=False)

     Stops the VM identified by =vm_id=.

     *Parameters*:
                 + vm_id - VM/instance id of the VM to be stopped.
                 + dry_run(bool) - Set to True if the operation should not actually run.

     *Returns*: List of instances that got stopped.

4. *restart_vm* (self, vm_id, dry_run=False)

     Stops the VM identified by =vm_id= and then starts it again.

     *Parameters*:
                 + vm_id - VM/instance id of the VM to be started again.
                 + dry_run(bool) - Set to True if the operation should not actually run.

     *Returns*: List of instances that got restarted.

5. *start_vm_manager* (self, vm_id )

     Starts the VM manager service inside the VM identified by =vm_id=.

     *Parameters*:
                 + vm_id - VM/instance id of the VM.

     *Returns*: True if the VM Manager service has successfully started.

6. *destroy_vm* (self, vm_id, dry_run=False)

     Terminates the VM identified by =vm_id=.

     *Parameters*:
                 + vm_id - VM/instance id of the VM to be terminated.
                 + dry_run(bool) - Set to True if the operation should not actually run.

     *Returns*: List of instances that got terminated.

7. *is_running_vm* (self, vm_ip)

     Checks if the VM is up and port 22 is reachable. It assumes that
     VM is running the SSH service.

     *Parameters*:
                 + vm_ip - The ip address of VM.

     *Returns*: True if the VM is up, else False.

** Configuration parameters of the adapter
Following are the parameters which are needed to be configured in this
adapter, for the adapter to be able to communicate with AWS APIs.

1. *region*: The data centre region in which an AWS connection is to
   be made to create instances/VMs. Each region is a separate
   geographic area. More information about AWS regions [[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html][here]].

2. *credentials*: Credentials are used to authenticate the API to
   AWS. The REST API uses *access keys* as the credentials. The access
   key has two parts:

   + *Access Key ID* - It identifies the party responsible for service
     requests. It is included in each request, so it's not a secret.

   + *Secret Access Key* - Each Access Key ID has a Secret Access Key
     associated with it. This key is just a long string of characters
     (and not a file) that is used to calculate the digital signature
     included in the request. More information [[http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html][here]].

   Both region and credentials are required whenever a new connection
   is established. Within this connection, a number of VMs could be
   created.

3. *subnet_id*: The id of the subnet to be associated with an instance
   or VM. This is used while creating an instance or VMs. More
   information [[http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html][here]].

4. *security_group_ids*: A list of ids of the security groups to be
   associated with an instance or VM. This is used while creating an
   instance or VMs. More information about security groups [[http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html][here]].

5. *key_name*: The name of the key pair with which to launch
   instances. More information [[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html][here]].

These parameters come from a configuration file which is not checked
in to the repository. Instead, a sample configuration file is checked
in. A deployer is responsible for modifying this file and filling the
appropriate values.

** Sequence of steps in AWSAdapter
[[./Sequence diagram of AWSAdapter.png]]

Following is the sequence of events that occur when a lab is deployed
on AWS using =AWSAdapter=:

1. =VMPoolManager= sends an HTTP Request to =AdapterServer= indicating
   that a VM needs to be created. It also passes the lab spec that
   includes VM requirements.

2. On receiving this request, the =AdapterServer= calls the =create_vm()=
   function of =AWSAdapter= and hands over the lab spec to it.

3. Based on lab spec(as mentioned below), the =AWSAdapter= selects an AMI and
   instance type for the VM.

4. It creates a VM on AWS Cluster.

5. The VM/instance id of the newly created VM is returned to the
   =AdapterServer=.

6. The =AdapterServer= now calls the =init_vm()= function of =AWSAdapter=.

7. This initializes the newly created VM on AWS Cluster by copying
   relevant ADS component (=VMManager=) and lab sources, and starts
   the =VMManager= service.

8. Once this service has started, the =AWSAdapter= sends back a tuple to
   the =AdapterServer= consisting of a boolean value(that indicates
   success/failure), instance/VM id of the VM on AWS Cluster, IP
   address of the VM, and port on which the =VMManager= service is
   running.

9. The latter three are forwarded by =AdapterServer= as the HTTP response
   to the =VMPoolManager=.

** Internal Design
*** TODO How to select an AMI based on the lab spec input?
TODO
*** TODO How to select an instance type based on the lab spec input?
TODO

** Strategic decisions:
*** What OS/AMIs to support?
AWS uses OS images to associate with an instance when one brings up an
instance. AWS calls these OS images as AMIs.
([[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html]])
To provision instances we need to choose AMIs, hence we needed to
decide on what OS and AMIs we would support.

- In the existing implementation of ADS on CentOS-OpenVZ platform - Ubuntu,
  CentOS and Debian were supported. The decision is to go ahead with these
  OSes, considering almost all the current labs(level 5 and hosted labs on
  IIIT infrastructure) use Ubuntu 10.04/12.04.
- Regarding versions of the OS, we decided:
  + Ubuntu::
    + Only LTS versions is supported.
    + Ubuntu 10.04:: Has reached end of life of support and hence we also
      cannot support it, even though some lab developers have communicated
      that they have a hard dependency on this version of Ubuntu.
    + Ubuntu 12.04:: Supported, as its end of life is 2017.
    + Ubuntu 14.04:: Supported, as its end of life 2019.
  + CentOS::
    + CentOS 6.6:: Supported. This is the current stable version.
    + CentOS 6.5:: Requests to use CentOS 6.5 will automatically be upgraded
      to use CentOS 6.6.
  + Debian::
    +  Debian 7.x:: Supported, as end of life is 2016.

*** What machine configuration/instance types to support?
As AWS has the concept of instance types (which is essentially a set of
machine configuration), we need to select a set of instance types that we
support.
All the instance types available on AWS are listed here:
[[https://aws.amazon.com/ec2/instance-types/]]

Looking at most of the lab requirements, we concluded that having instance
types with 2GB and 4GB RAM would suffice them.
For storage, AWS has a concept of
EBS([[https://aws.amazon.com/ebs/getting-started/]]). The default EBS is of
8GB with our current instance types.
Our conclusion was for the current labs, the default EBS should be fine. In a
later version, the adapter can add the storage dynamically.

Hence, the current supported AWS instance types by AWSAdapter are:
+ t2.micro (1GB RAM)
+ t2.small (2GB RAM)


* Implementation
The implementation of the AWSAdapter can be found here:
[[../src/adapters/AWSAdapter.py]]


* Other related documentation
*** TODO How to create an AMI for lab deployment?
TODO


* Testing
** Objective
+ To validate the creation of a VM on AWS platform.
+ To ensure that the VMManager service is running on this VM.

** Testing Environment

1. A VM is provisioned on AWS, such that it is able to access the
   internet.
2. The *state* of this instance/VM is *running*.

TODO - Where to mention setting up of this (1) testing environment?
** Assumptions
1. ADS is configured and running in the provisioned VM.
2. The source code of ADS is copied in =/labs= folder. However, the
   test module also takes care of this prerequisite.
3. The test cases are written and tested for AWSAdapter.

** Test Cases
*** Case 01: To test the creation of a Virtual Machine on AWS platform.
This is achieved by checking the state of the newly created
instance. The state should return integer values *0* or *16*, indicating
that the instance is either *pending* or already *running*.

*** Case 02: To test the initialization of VM
The objective of this test is to validate if the lab sources and
VMManager is copied and VMManager service is running. This is tested
by asserting the boolean value returned after successful
initialization of the VM.

*** Case 03: To test if the VMManager service is running
After the instance is initialized, it is necessary to validate if the
VMManager sevice is actually running or not. This is tested by
asserting the response to an HTTP request sent on the VM's IP and
vmmanager's port no.

[[https://github.com/vlead/ovpl/blob/aws-adapter/tests/test_AWSAdapter.py][Click here to view the implementation of test cases
